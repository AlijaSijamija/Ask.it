{"ast":null,"code":"import API_ROUTE from \"../../../../apiRoute\";\nimport axios from 'axios';\nimport { BEFORE_STATE_QUESTION, FETCH_QUESTIONS, FETCH_QUESTIONS_ERROR, GET_QUESTION_ERROR, CREATE_QUESTION_SUCCESS, CREATE_QUESTION_ERROR, DELETE_QUESTION_SUCCESS, DELETE_QUESTION_ERROR, FETCH_AUTH_QUESTIONS, FETCH_AUTH_QUESTIONS_ERROR } from '../questionsTypes';\nimport { history } from '../../../../history';\nexport const fetchQuestions = () => {\n  return dispatch => {\n    axios.get(`${API_ROUTE}/questions`).then(res => {\n      dispatch({\n        type: FETCH_QUESTIONS,\n        payload: res.data.response\n      });\n    }).catch(err => {\n      dispatch({\n        type: FETCH_QUESTIONS_ERROR,\n        payload: err.response ? err.respons.data.error : \"\"\n      });\n    });\n  };\n};\nexport const fetchQuestion = id => {\n  return async dispatch => {\n    dispatch({\n      type: BEFORE_STATE_QUESTION\n    });\n\n    try {\n      const res = await axios.get(`${API_ROUTE}/questions/${id}`);\n      dispatch({\n        type: GET_QUESTION_SUCCESS,\n        payload: res.data.response\n      });\n    } catch (err) {\n      dispatch({\n        type: GET_QUESTION_ERROR,\n        payload: err.response.data.error\n      });\n      history.push('/'); //incase the user manually enter the param that dont exist\n    }\n  };\n};\nexport const fetchAuthQuestions = id => {\n  return async dispatch => {\n    dispatch({\n      type: BEFORE_STATE_QUESTION\n    });\n\n    try {\n      const res = await axios.get(`${API_ROUTE}/questions_user/${id}`);\n      dispatch({\n        type: FETCH_AUTH_QUESTIONS,\n        payload: res.data.response\n      });\n    } catch (err) {\n      dispatch({\n        type: FETCH_AUTH_QUESTIONS_ERROR,\n        payload: err.response.data.error\n      });\n    }\n  };\n};\nexport const createQuestion = createQuestion => {\n  return async dispatch => {\n    dispatch({\n      type: BEFORE_STATE_QUESTION\n    });\n\n    try {\n      const res = await axios.post(`${API_ROUTE}/posts`, createQuestion);\n      dispatch({\n        type: CREATE_QUESTION_SUCCESS,\n        payload: res.data.response\n      });\n      history.push('/');\n    } catch (err) {\n      dispatch({\n        type: CREATE_QUESTION_ERROR,\n        payload: err.response.data.error\n      });\n    }\n  };\n};\nexport const deleteQuestion = id => {\n  return async dispatch => {\n    dispatch({\n      type: BEFORE_STATE_QUESTION\n    });\n\n    try {\n      const res = await axios.delete(`${API_ROUTE}/posts/${id}`);\n      dispatch({\n        type: DELETE_QUESTION_SUCCESS,\n        payload: {\n          deletedID: id,\n          message: res.data.response\n        }\n      });\n      history.push('/');\n    } catch (err) {\n      dispatch({\n        type: DELETE_QUESTION_ERROR,\n        payload: err.response.data.error\n      });\n    }\n  };\n};","map":{"version":3,"sources":["C:/Users/admin/Desktop/Ministry of Programming/askit/src/store/modules/questions/actions/questionsAction.js"],"names":["API_ROUTE","axios","BEFORE_STATE_QUESTION","FETCH_QUESTIONS","FETCH_QUESTIONS_ERROR","GET_QUESTION_ERROR","CREATE_QUESTION_SUCCESS","CREATE_QUESTION_ERROR","DELETE_QUESTION_SUCCESS","DELETE_QUESTION_ERROR","FETCH_AUTH_QUESTIONS","FETCH_AUTH_QUESTIONS_ERROR","history","fetchQuestions","dispatch","get","then","res","type","payload","data","response","catch","err","respons","error","fetchQuestion","id","GET_QUESTION_SUCCESS","push","fetchAuthQuestions","createQuestion","post","deleteQuestion","delete","deletedID","message"],"mappings":"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","sourcesContent":["import API_ROUTE from \"../../../../apiRoute\";\r\nimport axios from 'axios'\r\nimport { BEFORE_STATE_QUESTION, FETCH_QUESTIONS, FETCH_QUESTIONS_ERROR, GET_QUESTION_ERROR, \r\n  CREATE_QUESTION_SUCCESS, CREATE_QUESTION_ERROR, DELETE_QUESTION_SUCCESS, \r\n  DELETE_QUESTION_ERROR, FETCH_AUTH_QUESTIONS, FETCH_AUTH_QUESTIONS_ERROR  } from '../questionsTypes'\r\nimport  {history} from '../../../../history'\r\n\r\n \r\nexport const fetchQuestions = () => {\r\n\r\n  return (dispatch) => {\r\n\r\n    axios.get(`${API_ROUTE}/questions`).then(res => {\r\n      dispatch({ type: FETCH_QUESTIONS, payload: res.data.response })\r\n    }).catch(err => {\r\n      dispatch({ type: FETCH_QUESTIONS_ERROR, payload: err.response ? err.respons.data.error : \"\" })\r\n    })\r\n  }\r\n}\r\n\r\nexport const fetchQuestion = id => {\r\n\r\n  return async (dispatch) => {\r\n\r\n    dispatch({ type: BEFORE_STATE_QUESTION })\r\n\r\n    try {\r\n      const res  = await axios.get(`${API_ROUTE}/questions/${id}`)\r\n      dispatch({ type: GET_QUESTION_SUCCESS, payload: res.data.response })\r\n    } catch(err){\r\n      dispatch({ type: GET_QUESTION_ERROR, payload: err.response.data.error })\r\n      history.push('/'); //incase the user manually enter the param that dont exist\r\n    }\r\n  }\r\n}\r\n\r\nexport const fetchAuthQuestions = id => {\r\n\r\n  return async (dispatch) => {\r\n\r\n    dispatch({ type: BEFORE_STATE_QUESTION })\r\n\r\n    try {\r\n      const res  = await axios.get(`${API_ROUTE}/questions_user/${id}`)\r\n      dispatch({ type: FETCH_AUTH_QUESTIONS, payload: res.data.response })\r\n    } catch(err){\r\n      dispatch({ type: FETCH_AUTH_QUESTIONS_ERROR, payload: err.response.data.error })\r\n    }\r\n  }\r\n}\r\n\r\nexport const createQuestion = (createQuestion) => {\r\n  return async (dispatch) => {\r\n\r\n    dispatch({ type: BEFORE_STATE_QUESTION })\r\n\r\n    try {\r\n      const res = await axios.post(`${API_ROUTE}/posts`, createQuestion)\r\n      dispatch({ \r\n        type: CREATE_QUESTION_SUCCESS,  \r\n        payload: res.data.response\r\n      })\r\n      history.push('/');\r\n    } catch(err) {\r\n      dispatch({ type: CREATE_QUESTION_ERROR, payload: err.response.data.error })\r\n    }\r\n  }\r\n}\r\n\r\nexport const deleteQuestion = (id) => {\r\n\r\n  return async (dispatch) => {\r\n\r\n    dispatch({ type: BEFORE_STATE_QUESTION })\r\n\r\n    try {\r\n      const res = await axios.delete(`${API_ROUTE}/posts/${id}`)\r\n      dispatch({ \r\n        type: DELETE_QUESTION_SUCCESS,\r\n        payload: {\r\n          deletedID: id,\r\n          message: res.data.response\r\n        } \r\n      })\r\n      history.push('/');\r\n    } catch(err) {\r\n      dispatch({ type: DELETE_QUESTION_ERROR, payload: err.response.data.error })\r\n    }\r\n  }\r\n}"]},"metadata":{},"sourceType":"module"}